{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildRootChain = buildRootChain;\nexports.buildPresetChainWalker = void 0;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./validation/options\");\n\nvar _patternToRegex = require(\"./pattern-to-regex\");\n\nvar _printer = require(\"./printer\");\n\nvar _files = require(\"./files\");\n\nvar _caching = require(\"./caching\");\n\nvar _configDescriptors = require(\"./config-descriptors\");\n\nconst debug = _debug()(\"babel:config:config-chain\");\n\nfunction* buildPresetChain(arg, context) {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    files: new Set()\n  };\n}\n\nconst buildPresetChainWalker = makeChainWalker({\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName),\n  createLogger: () => () => {}\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nconst loadPresetDescriptors = (0, _caching.makeWeakCacheSync)(preset => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));\nconst loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));\nconst loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction* buildRootChain(opts, context) {\n  let configReport, babelRcReport;\n  const programmaticLogger = new _printer.ConfigPrinter();\n  const programmaticChain = yield* loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context, undefined, programmaticLogger);\n  if (!programmaticChain) return null;\n  const programmaticReport = yield* programmaticLogger.output();\n  let configFile;\n\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = yield* (0, _files.findRootConfig)(context.root, context.envName, context.caller);\n  }\n\n  let {\n    babelrc,\n    babelrcRoots\n  } = opts;\n  let babelrcRootsDirectory = context.cwd;\n  const configFileChain = emptyChain();\n  const configFileLogger = new _printer.ConfigPrinter();\n\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(validatedFile, context, undefined, configFileLogger);\n    if (!result) return null;\n    configReport = yield* configFileLogger.output();\n\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n\n    mergeChain(configFileChain, result);\n  }\n\n  let ignoreFile, babelrcFile;\n  let isIgnored = false;\n  const fileChain = emptyChain();\n\n  if ((babelrc === true || babelrc === undefined) && typeof context.filename === \"string\") {\n    const pkgData = yield* (0, _files.findPackageData)(context.filename);\n\n    if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n      ({\n        ignore: ignoreFile,\n        config: babelrcFile\n      } = yield* (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller));\n\n      if (ignoreFile) {\n        fileChain.files.add(ignoreFile.filepath);\n      }\n\n      if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n        isIgnored = true;\n      }\n\n      if (babelrcFile && !isIgnored) {\n        const validatedFile = validateBabelrcFile(babelrcFile);\n        const babelrcLogger = new _printer.ConfigPrinter();\n        const result = yield* loadFileChain(validatedFile, context, undefined, babelrcLogger);\n\n        if (!result) {\n          isIgnored = true;\n        } else {\n          babelRcReport = yield* babelrcLogger.output();\n          mergeChain(fileChain, result);\n        }\n      }\n\n      if (babelrcFile && isIgnored) {\n        fileChain.files.add(babelrcFile.filepath);\n      }\n    }\n  }\n\n  if (context.showConfig) {\n    console.log(`Babel configs on \"${context.filename}\" (ascending priority):\\n` + [configReport, babelRcReport, programmaticReport].filter(x => !!x).join(\"\\n\\n\") + \"\\n-----End Babel configs-----\");\n  }\n\n  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),\n    presets: isIgnored ? [] : dedupDescriptors(chain.presets),\n    options: isIgnored ? [] : chain.options.map(o => normalizeOptions(o)),\n    fileHandling: isIgnored ? \"ignored\" : \"transpile\",\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined,\n    files: chain.files\n  };\n}\n\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  const absoluteRoot = context.root;\n\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  let babelrcPatterns = babelrcRoots;\n\n  if (!Array.isArray(babelrcPatterns)) {\n    babelrcPatterns = [babelrcPatterns];\n  }\n\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\" ? _path().resolve(babelrcRootsDirectory, pat) : pat;\n  });\n\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\n\nconst validateConfigFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"configfile\", file.options)\n}));\nconst validateBabelrcFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"babelrcfile\", file.options)\n}));\nconst validateExtendFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"extendsfile\", file.options)\n}));\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors),\n  env: (input, envName) => buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName),\n  overrides: (input, index) => buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName),\n  createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)\n});\nconst loadFileChainWalker = makeChainWalker({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName),\n  createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)\n});\n\nfunction* loadFileChain(input, context, files, baseLogger) {\n  const chain = yield* loadFileChainWalker(input, context, files, baseLogger);\n\n  if (chain) {\n    chain.files.add(input.filepath);\n  }\n\n  return chain;\n}\n\nconst loadFileDescriptors = (0, _caching.makeWeakCacheSync)(file => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));\nconst loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));\nconst loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction buildFileLogger(filepath, context, baseLogger) {\n  if (!baseLogger) {\n    return () => {};\n  }\n\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {\n    filepath\n  });\n}\n\nfunction buildRootDescriptors({\n  dirname,\n  options\n}, alias, descriptors) {\n  return descriptors(dirname, options, alias);\n}\n\nfunction buildProgrammaticLogger(_, context, baseLogger) {\n  var _context$caller;\n\n  if (!baseLogger) {\n    return () => {};\n  }\n\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {\n    callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name\n  });\n}\n\nfunction buildEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, envName) {\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\n\nfunction buildOverrideDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index) {\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\n\nfunction buildOverrideEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index, envName) {\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  const opts = override.env && override.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[\"${envName}\"]`) : null;\n}\n\nfunction makeChainWalker({\n  root,\n  env,\n  overrides,\n  overridesEnv,\n  createLogger\n}) {\n  return function* (input, context, files = new Set(), baseLogger) {\n    const {\n      dirname\n    } = input;\n    const flattenedConfigs = [];\n    const rootOpts = root(input);\n\n    if (configIsApplicable(rootOpts, dirname, context)) {\n      flattenedConfigs.push({\n        config: rootOpts,\n        envName: undefined,\n        index: undefined\n      });\n      const envOpts = env(input, context.envName);\n\n      if (envOpts && configIsApplicable(envOpts, dirname, context)) {\n        flattenedConfigs.push({\n          config: envOpts,\n          envName: context.envName,\n          index: undefined\n        });\n      }\n\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n\n        if (configIsApplicable(overrideOps, dirname, context)) {\n          flattenedConfigs.push({\n            config: overrideOps,\n            index,\n            envName: undefined\n          });\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n\n          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {\n            flattenedConfigs.push({\n              config: overrideEnvOpts,\n              index,\n              envName: context.envName\n            });\n          }\n        }\n      });\n    }\n\n    if (flattenedConfigs.some(({\n      config: {\n        options: {\n          ignore,\n          only\n        }\n      }\n    }) => shouldIgnore(context, ignore, only, dirname))) {\n      return null;\n    }\n\n    const chain = emptyChain();\n    const logger = createLogger(input, context, baseLogger);\n\n    for (const {\n      config,\n      index,\n      envName\n    } of flattenedConfigs) {\n      if (!(yield* mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger))) {\n        return null;\n      }\n\n      logger(config, index, envName);\n      yield* mergeChainOpts(chain, config);\n    }\n\n    return chain;\n  };\n}\n\nfunction* mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {\n  if (opts.extends === undefined) return true;\n  const file = yield* (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n\n  if (files.has(file)) {\n    throw new Error(`Configuration cycle detected loading ${file.filepath}.\\n` + `File already loaded following the config chain:\\n` + Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"));\n  }\n\n  files.add(file);\n  const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\n\nfunction mergeChain(target, source) {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n\n  for (const file of source.files) {\n    target.files.add(file);\n  }\n\n  return target;\n}\n\nfunction* mergeChainOpts(target, {\n  options,\n  plugins,\n  presets\n}) {\n  target.options.push(options);\n  target.plugins.push(...(yield* plugins()));\n  target.presets.push(...(yield* presets()));\n  return target;\n}\n\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: [],\n    files: new Set()\n  };\n}\n\nfunction normalizeOptions(opts) {\n  const options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n\n  return options;\n}\n\nfunction dedupDescriptors(items) {\n  const map = new Map();\n  const descriptors = [];\n\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n\n      let desc = nameMap.get(item.name);\n\n      if (!desc) {\n        desc = {\n          value: item\n        };\n        descriptors.push(desc);\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({\n        value: item\n      });\n    }\n  }\n\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable({\n  options\n}, dirname, context) {\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));\n}\n\nfunction configFieldIsApplicable(context, test, dirname) {\n  const patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname);\n}\n\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    var _context$filename;\n\n    const message = `No config is applied to \"${(_context$filename = context.filename) != null ? _context$filename : \"(unknown)\"}\" because it matches one of \\`ignore: ${JSON.stringify(ignore)}\\` from \"${dirname}\"`;\n    debug(message);\n\n    if (context.showConfig) {\n      console.log(message);\n    }\n\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    var _context$filename2;\n\n    const message = `No config is applied to \"${(_context$filename2 = context.filename) != null ? _context$filename2 : \"(unknown)\"}\" because it fails to match one of \\`only: ${JSON.stringify(only)}\\` from \"${dirname}\"`;\n    debug(message);\n\n    if (context.showConfig) {\n      console.log(message);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction matchesPatterns(context, patterns, dirname) {\n  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context));\n}\n\nfunction matchPattern(pattern, dirname, pathToTest, context) {\n  if (typeof pattern === \"function\") {\n    return !!pattern(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new Error(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`);\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n\n  return pattern.test(pathToTest);\n}","map":{"version":3,"sources":["/Users/josh/Projects/GalaxyGirl/g-girl/node_modules/@babel/core/lib/config/config-chain.js"],"names":["Object","defineProperty","exports","value","buildPresetChain","buildRootChain","buildPresetChainWalker","_path","data","require","_debug","_options","_patternToRegex","_printer","_files","_caching","_configDescriptors","debug","arg","context","chain","plugins","dedupDescriptors","presets","options","map","o","normalizeOptions","files","Set","makeChainWalker","root","preset","loadPresetDescriptors","env","envName","loadPresetEnvDescriptors","overrides","index","loadPresetOverridesDescriptors","overridesEnv","loadPresetOverridesEnvDescriptors","createLogger","makeWeakCacheSync","buildRootDescriptors","alias","createUncachedDescriptors","makeStrongCacheSync","buildEnvDescriptors","buildOverrideDescriptors","buildOverrideEnvDescriptors","opts","configReport","babelRcReport","programmaticLogger","ConfigPrinter","programmaticChain","loadProgrammaticChain","dirname","cwd","undefined","programmaticReport","output","configFile","loadConfig","caller","findRootConfig","babelrc","babelrcRoots","babelrcRootsDirectory","configFileChain","emptyChain","configFileLogger","validatedFile","validateConfigFile","result","loadFileChain","mergeChain","ignoreFile","babelrcFile","isIgnored","fileChain","filename","pkgData","findPackageData","babelrcLoadEnabled","ignore","config","findRelativeConfig","add","filepath","shouldIgnore","validateBabelrcFile","babelrcLogger","showConfig","console","log","filter","x","join","fileHandling","absoluteRoot","directories","indexOf","babelrcPatterns","Array","isArray","pat","resolve","length","some","default","directory","matchPattern","file","validate","validateExtendFile","input","createCachedDescriptors","baseLogger","buildProgrammaticLogger","loadFileChainWalker","loadFileDescriptors","loadFileEnvDescriptors","loadFileOverridesDescriptors","loadFileOverridesEnvDescriptors","buildFileLogger","configure","ChainFormatter","Config","descriptors","_","_context$caller","Programmatic","callerName","name","Error","override","flattenedConfigs","rootOpts","configIsApplicable","push","envOpts","forEach","overrideOps","overrideEnvOpts","only","logger","mergeExtendsChain","mergeChainOpts","extends","has","from","delete","target","source","assign","passPerPreset","test","include","exclude","prototype","hasOwnProperty","call","sourceMaps","sourceMap","items","Map","item","fnKey","nameMap","get","set","desc","ownPass","reduce","acc","configFieldIsApplicable","patterns","matchesPatterns","_context$filename","message","JSON","stringify","_context$filename2","pattern","pathToTest"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildRootChain = buildRootChain;\nexports.buildPresetChainWalker = void 0;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./validation/options\");\n\nvar _patternToRegex = require(\"./pattern-to-regex\");\n\nvar _printer = require(\"./printer\");\n\nvar _files = require(\"./files\");\n\nvar _caching = require(\"./caching\");\n\nvar _configDescriptors = require(\"./config-descriptors\");\n\nconst debug = _debug()(\"babel:config:config-chain\");\n\nfunction* buildPresetChain(arg, context) {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    files: new Set()\n  };\n}\n\nconst buildPresetChainWalker = makeChainWalker({\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName),\n  createLogger: () => () => {}\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nconst loadPresetDescriptors = (0, _caching.makeWeakCacheSync)(preset => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));\nconst loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));\nconst loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction* buildRootChain(opts, context) {\n  let configReport, babelRcReport;\n  const programmaticLogger = new _printer.ConfigPrinter();\n  const programmaticChain = yield* loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context, undefined, programmaticLogger);\n  if (!programmaticChain) return null;\n  const programmaticReport = yield* programmaticLogger.output();\n  let configFile;\n\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = yield* (0, _files.findRootConfig)(context.root, context.envName, context.caller);\n  }\n\n  let {\n    babelrc,\n    babelrcRoots\n  } = opts;\n  let babelrcRootsDirectory = context.cwd;\n  const configFileChain = emptyChain();\n  const configFileLogger = new _printer.ConfigPrinter();\n\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(validatedFile, context, undefined, configFileLogger);\n    if (!result) return null;\n    configReport = yield* configFileLogger.output();\n\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n\n    mergeChain(configFileChain, result);\n  }\n\n  let ignoreFile, babelrcFile;\n  let isIgnored = false;\n  const fileChain = emptyChain();\n\n  if ((babelrc === true || babelrc === undefined) && typeof context.filename === \"string\") {\n    const pkgData = yield* (0, _files.findPackageData)(context.filename);\n\n    if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n      ({\n        ignore: ignoreFile,\n        config: babelrcFile\n      } = yield* (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller));\n\n      if (ignoreFile) {\n        fileChain.files.add(ignoreFile.filepath);\n      }\n\n      if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n        isIgnored = true;\n      }\n\n      if (babelrcFile && !isIgnored) {\n        const validatedFile = validateBabelrcFile(babelrcFile);\n        const babelrcLogger = new _printer.ConfigPrinter();\n        const result = yield* loadFileChain(validatedFile, context, undefined, babelrcLogger);\n\n        if (!result) {\n          isIgnored = true;\n        } else {\n          babelRcReport = yield* babelrcLogger.output();\n          mergeChain(fileChain, result);\n        }\n      }\n\n      if (babelrcFile && isIgnored) {\n        fileChain.files.add(babelrcFile.filepath);\n      }\n    }\n  }\n\n  if (context.showConfig) {\n    console.log(`Babel configs on \"${context.filename}\" (ascending priority):\\n` + [configReport, babelRcReport, programmaticReport].filter(x => !!x).join(\"\\n\\n\") + \"\\n-----End Babel configs-----\");\n  }\n\n  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),\n    presets: isIgnored ? [] : dedupDescriptors(chain.presets),\n    options: isIgnored ? [] : chain.options.map(o => normalizeOptions(o)),\n    fileHandling: isIgnored ? \"ignored\" : \"transpile\",\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined,\n    files: chain.files\n  };\n}\n\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  const absoluteRoot = context.root;\n\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  let babelrcPatterns = babelrcRoots;\n\n  if (!Array.isArray(babelrcPatterns)) {\n    babelrcPatterns = [babelrcPatterns];\n  }\n\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\" ? _path().resolve(babelrcRootsDirectory, pat) : pat;\n  });\n\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\n\nconst validateConfigFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"configfile\", file.options)\n}));\nconst validateBabelrcFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"babelrcfile\", file.options)\n}));\nconst validateExtendFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"extendsfile\", file.options)\n}));\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors),\n  env: (input, envName) => buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName),\n  overrides: (input, index) => buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName),\n  createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)\n});\nconst loadFileChainWalker = makeChainWalker({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName),\n  createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)\n});\n\nfunction* loadFileChain(input, context, files, baseLogger) {\n  const chain = yield* loadFileChainWalker(input, context, files, baseLogger);\n\n  if (chain) {\n    chain.files.add(input.filepath);\n  }\n\n  return chain;\n}\n\nconst loadFileDescriptors = (0, _caching.makeWeakCacheSync)(file => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));\nconst loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));\nconst loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction buildFileLogger(filepath, context, baseLogger) {\n  if (!baseLogger) {\n    return () => {};\n  }\n\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {\n    filepath\n  });\n}\n\nfunction buildRootDescriptors({\n  dirname,\n  options\n}, alias, descriptors) {\n  return descriptors(dirname, options, alias);\n}\n\nfunction buildProgrammaticLogger(_, context, baseLogger) {\n  var _context$caller;\n\n  if (!baseLogger) {\n    return () => {};\n  }\n\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {\n    callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name\n  });\n}\n\nfunction buildEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, envName) {\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\n\nfunction buildOverrideDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index) {\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\n\nfunction buildOverrideEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index, envName) {\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  const opts = override.env && override.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[\"${envName}\"]`) : null;\n}\n\nfunction makeChainWalker({\n  root,\n  env,\n  overrides,\n  overridesEnv,\n  createLogger\n}) {\n  return function* (input, context, files = new Set(), baseLogger) {\n    const {\n      dirname\n    } = input;\n    const flattenedConfigs = [];\n    const rootOpts = root(input);\n\n    if (configIsApplicable(rootOpts, dirname, context)) {\n      flattenedConfigs.push({\n        config: rootOpts,\n        envName: undefined,\n        index: undefined\n      });\n      const envOpts = env(input, context.envName);\n\n      if (envOpts && configIsApplicable(envOpts, dirname, context)) {\n        flattenedConfigs.push({\n          config: envOpts,\n          envName: context.envName,\n          index: undefined\n        });\n      }\n\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n\n        if (configIsApplicable(overrideOps, dirname, context)) {\n          flattenedConfigs.push({\n            config: overrideOps,\n            index,\n            envName: undefined\n          });\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n\n          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {\n            flattenedConfigs.push({\n              config: overrideEnvOpts,\n              index,\n              envName: context.envName\n            });\n          }\n        }\n      });\n    }\n\n    if (flattenedConfigs.some(({\n      config: {\n        options: {\n          ignore,\n          only\n        }\n      }\n    }) => shouldIgnore(context, ignore, only, dirname))) {\n      return null;\n    }\n\n    const chain = emptyChain();\n    const logger = createLogger(input, context, baseLogger);\n\n    for (const {\n      config,\n      index,\n      envName\n    } of flattenedConfigs) {\n      if (!(yield* mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger))) {\n        return null;\n      }\n\n      logger(config, index, envName);\n      yield* mergeChainOpts(chain, config);\n    }\n\n    return chain;\n  };\n}\n\nfunction* mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {\n  if (opts.extends === undefined) return true;\n  const file = yield* (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n\n  if (files.has(file)) {\n    throw new Error(`Configuration cycle detected loading ${file.filepath}.\\n` + `File already loaded following the config chain:\\n` + Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"));\n  }\n\n  files.add(file);\n  const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\n\nfunction mergeChain(target, source) {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n\n  for (const file of source.files) {\n    target.files.add(file);\n  }\n\n  return target;\n}\n\nfunction* mergeChainOpts(target, {\n  options,\n  plugins,\n  presets\n}) {\n  target.options.push(options);\n  target.plugins.push(...(yield* plugins()));\n  target.presets.push(...(yield* presets()));\n  return target;\n}\n\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: [],\n    files: new Set()\n  };\n}\n\nfunction normalizeOptions(opts) {\n  const options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n\n  return options;\n}\n\nfunction dedupDescriptors(items) {\n  const map = new Map();\n  const descriptors = [];\n\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n\n      let desc = nameMap.get(item.name);\n\n      if (!desc) {\n        desc = {\n          value: item\n        };\n        descriptors.push(desc);\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({\n        value: item\n      });\n    }\n  }\n\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable({\n  options\n}, dirname, context) {\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));\n}\n\nfunction configFieldIsApplicable(context, test, dirname) {\n  const patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname);\n}\n\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    var _context$filename;\n\n    const message = `No config is applied to \"${(_context$filename = context.filename) != null ? _context$filename : \"(unknown)\"}\" because it matches one of \\`ignore: ${JSON.stringify(ignore)}\\` from \"${dirname}\"`;\n    debug(message);\n\n    if (context.showConfig) {\n      console.log(message);\n    }\n\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    var _context$filename2;\n\n    const message = `No config is applied to \"${(_context$filename2 = context.filename) != null ? _context$filename2 : \"(unknown)\"}\" because it fails to match one of \\`only: ${JSON.stringify(only)}\\` from \"${dirname}\"`;\n    debug(message);\n\n    if (context.showConfig) {\n      console.log(message);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction matchesPatterns(context, patterns, dirname) {\n  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context));\n}\n\nfunction matchPattern(pattern, dirname, pathToTest, context) {\n  if (typeof pattern === \"function\") {\n    return !!pattern(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new Error(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`);\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n\n  return pattern.test(pathToTest);\n}"]},"metadata":{},"sourceType":"script"}