{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.assertSimpleType = assertSimpleType;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nconst synchronize = gen => {\n  return _gensync()(gen).sync;\n};\n\nfunction* genTrue() {\n  return true;\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  const callCacheSync = new CallCache();\n  const callCacheAsync = new CallCache();\n  const futureCache = new CallCache();\n  return function* cachedFunction(arg, data) {\n    const asyncContext = yield* (0, _async.isAsync)();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n    const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);\n    if (cached.valid) return cached.value;\n    const cache = new CacheConfigurator(data);\n    const handlerResult = handler(arg, cache);\n    let finishLock;\n    let value;\n\n    if ((0, _util.isIterableIterator)(handlerResult)) {\n      const gen = handlerResult;\n      value = yield* (0, _async.onFirstPause)(gen, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n\n    updateFunctionCache(callCache, cache, arg, value);\n\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n\n    return value;\n  };\n}\n\nfunction* getCachedValue(cache, arg, data) {\n  const cachedValue = cache.get(arg);\n\n  if (cachedValue) {\n    for (const {\n      value,\n      valid\n    } of cachedValue) {\n      if (yield* valid(data)) return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  const cached = yield* getCachedValue(callCache, arg, data);\n\n  if (cached.valid) {\n    return cached;\n  }\n\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n\n    if (cached.valid) {\n      const value = yield* (0, _async.waitFor)(cached.value.promise);\n      return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  const finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  let cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n\n    this._never = true;\n    this._configured = true;\n  }\n\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._configured = true;\n    const key = handler(this._data);\n    const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);\n\n    if ((0, _async.isThenable)(key)) {\n      return key.then(key => {\n        this._pairs.push([key, fn]);\n\n        return key;\n      });\n    }\n\n    this._pairs.push([key, fn]);\n\n    return key;\n  }\n\n  invalidate(handler) {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n\n  validator() {\n    const pairs = this._pairs;\n    return function* (data) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n\n      return true;\n    };\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n\n}\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n\n  cacheFn.forever = () => cache.forever();\n\n  cacheFn.never = () => cache.never();\n\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nclass Lock {\n  constructor() {\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  release(value) {\n    this.released = true;\n\n    this._resolve(value);\n  }\n\n}","map":{"version":3,"sources":["/Users/josh/Projects/GalaxyGirl/g-girl/node_modules/@babel/core/lib/config/caching.js"],"names":["Object","defineProperty","exports","value","makeWeakCache","makeWeakCacheSync","makeStrongCache","makeStrongCacheSync","assertSimpleType","_gensync","data","require","_async","_util","synchronize","gen","sync","genTrue","handler","makeCachedFunction","WeakMap","Map","CallCache","callCacheSync","callCacheAsync","futureCache","cachedFunction","arg","asyncContext","isAsync","callCache","cached","getCachedValueOrWait","valid","cache","CacheConfigurator","handlerResult","finishLock","isIterableIterator","onFirstPause","setupAsyncLocks","updateFunctionCache","delete","release","getCachedValue","cachedValue","get","waitFor","promise","config","Lock","configured","forever","deactivate","mode","set","validator","push","constructor","_active","_never","_forever","_invalidate","_configured","_pairs","_data","simple","makeSimpleConfigurator","Error","never","using","key","fn","maybeAsync","isThenable","then","invalidate","pairs","cacheFn","val","cb","released","_resolve","Promise","resolve"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,aAAR,GAAwBA,aAAxB;AACAF,OAAO,CAACG,iBAAR,GAA4BA,iBAA5B;AACAH,OAAO,CAACI,eAAR,GAA0BA,eAA1B;AACAJ,OAAO,CAACK,mBAAR,GAA8BA,mBAA9B;AACAL,OAAO,CAACM,gBAAR,GAA2BA,gBAA3B;;AAEA,SAASC,QAAT,GAAoB;AAClB,QAAMC,IAAI,GAAGC,OAAO,CAAC,SAAD,CAApB;;AAEAF,EAAAA,QAAQ,GAAG,YAAY;AACrB,WAAOC,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,IAAIE,MAAM,GAAGD,OAAO,CAAC,wBAAD,CAApB;;AAEA,IAAIE,KAAK,GAAGF,OAAO,CAAC,QAAD,CAAnB;;AAEA,MAAMG,WAAW,GAAGC,GAAG,IAAI;AACzB,SAAON,QAAQ,GAAGM,GAAH,CAAR,CAAgBC,IAAvB;AACD,CAFD;;AAIA,UAAUC,OAAV,GAAoB;AAClB,SAAO,IAAP;AACD;;AAED,SAASb,aAAT,CAAuBc,OAAvB,EAAgC;AAC9B,SAAOC,kBAAkB,CAACC,OAAD,EAAUF,OAAV,CAAzB;AACD;;AAED,SAASb,iBAAT,CAA2Ba,OAA3B,EAAoC;AAClC,SAAOJ,WAAW,CAACV,aAAa,CAACc,OAAD,CAAd,CAAlB;AACD;;AAED,SAASZ,eAAT,CAAyBY,OAAzB,EAAkC;AAChC,SAAOC,kBAAkB,CAACE,GAAD,EAAMH,OAAN,CAAzB;AACD;;AAED,SAASX,mBAAT,CAA6BW,OAA7B,EAAsC;AACpC,SAAOJ,WAAW,CAACR,eAAe,CAACY,OAAD,CAAhB,CAAlB;AACD;;AAED,SAASC,kBAAT,CAA4BG,SAA5B,EAAuCJ,OAAvC,EAAgD;AAC9C,QAAMK,aAAa,GAAG,IAAID,SAAJ,EAAtB;AACA,QAAME,cAAc,GAAG,IAAIF,SAAJ,EAAvB;AACA,QAAMG,WAAW,GAAG,IAAIH,SAAJ,EAApB;AACA,SAAO,UAAUI,cAAV,CAAyBC,GAAzB,EAA8BjB,IAA9B,EAAoC;AACzC,UAAMkB,YAAY,GAAG,OAAO,CAAC,GAAGhB,MAAM,CAACiB,OAAX,GAA5B;AACA,UAAMC,SAAS,GAAGF,YAAY,GAAGJ,cAAH,GAAoBD,aAAlD;AACA,UAAMQ,MAAM,GAAG,OAAOC,oBAAoB,CAACJ,YAAD,EAAeE,SAAf,EAA0BL,WAA1B,EAAuCE,GAAvC,EAA4CjB,IAA5C,CAA1C;AACA,QAAIqB,MAAM,CAACE,KAAX,EAAkB,OAAOF,MAAM,CAAC5B,KAAd;AAClB,UAAM+B,KAAK,GAAG,IAAIC,iBAAJ,CAAsBzB,IAAtB,CAAd;AACA,UAAM0B,aAAa,GAAGlB,OAAO,CAACS,GAAD,EAAMO,KAAN,CAA7B;AACA,QAAIG,UAAJ;AACA,QAAIlC,KAAJ;;AAEA,QAAI,CAAC,GAAGU,KAAK,CAACyB,kBAAV,EAA8BF,aAA9B,CAAJ,EAAkD;AAChD,YAAMrB,GAAG,GAAGqB,aAAZ;AACAjC,MAAAA,KAAK,GAAG,OAAO,CAAC,GAAGS,MAAM,CAAC2B,YAAX,EAAyBxB,GAAzB,EAA8B,MAAM;AACjDsB,QAAAA,UAAU,GAAGG,eAAe,CAACN,KAAD,EAAQT,WAAR,EAAqBE,GAArB,CAA5B;AACD,OAFc,CAAf;AAGD,KALD,MAKO;AACLxB,MAAAA,KAAK,GAAGiC,aAAR;AACD;;AAEDK,IAAAA,mBAAmB,CAACX,SAAD,EAAYI,KAAZ,EAAmBP,GAAnB,EAAwBxB,KAAxB,CAAnB;;AAEA,QAAIkC,UAAJ,EAAgB;AACdZ,MAAAA,WAAW,CAACiB,MAAZ,CAAmBf,GAAnB;AACAU,MAAAA,UAAU,CAACM,OAAX,CAAmBxC,KAAnB;AACD;;AAED,WAAOA,KAAP;AACD,GA3BD;AA4BD;;AAED,UAAUyC,cAAV,CAAyBV,KAAzB,EAAgCP,GAAhC,EAAqCjB,IAArC,EAA2C;AACzC,QAAMmC,WAAW,GAAGX,KAAK,CAACY,GAAN,CAAUnB,GAAV,CAApB;;AAEA,MAAIkB,WAAJ,EAAiB;AACf,SAAK,MAAM;AACT1C,MAAAA,KADS;AAET8B,MAAAA;AAFS,KAAX,IAGKY,WAHL,EAGkB;AAChB,UAAI,OAAOZ,KAAK,CAACvB,IAAD,CAAhB,EAAwB,OAAO;AAC7BuB,QAAAA,KAAK,EAAE,IADsB;AAE7B9B,QAAAA;AAF6B,OAAP;AAIzB;AACF;;AAED,SAAO;AACL8B,IAAAA,KAAK,EAAE,KADF;AAEL9B,IAAAA,KAAK,EAAE;AAFF,GAAP;AAID;;AAED,UAAU6B,oBAAV,CAA+BJ,YAA/B,EAA6CE,SAA7C,EAAwDL,WAAxD,EAAqEE,GAArE,EAA0EjB,IAA1E,EAAgF;AAC9E,QAAMqB,MAAM,GAAG,OAAOa,cAAc,CAACd,SAAD,EAAYH,GAAZ,EAAiBjB,IAAjB,CAApC;;AAEA,MAAIqB,MAAM,CAACE,KAAX,EAAkB;AAChB,WAAOF,MAAP;AACD;;AAED,MAAIH,YAAJ,EAAkB;AAChB,UAAMG,MAAM,GAAG,OAAOa,cAAc,CAACnB,WAAD,EAAcE,GAAd,EAAmBjB,IAAnB,CAApC;;AAEA,QAAIqB,MAAM,CAACE,KAAX,EAAkB;AAChB,YAAM9B,KAAK,GAAG,OAAO,CAAC,GAAGS,MAAM,CAACmC,OAAX,EAAoBhB,MAAM,CAAC5B,KAAP,CAAa6C,OAAjC,CAArB;AACA,aAAO;AACLf,QAAAA,KAAK,EAAE,IADF;AAEL9B,QAAAA;AAFK,OAAP;AAID;AACF;;AAED,SAAO;AACL8B,IAAAA,KAAK,EAAE,KADF;AAEL9B,IAAAA,KAAK,EAAE;AAFF,GAAP;AAID;;AAED,SAASqC,eAAT,CAAyBS,MAAzB,EAAiCxB,WAAjC,EAA8CE,GAA9C,EAAmD;AACjD,QAAMU,UAAU,GAAG,IAAIa,IAAJ,EAAnB;AACAT,EAAAA,mBAAmB,CAAChB,WAAD,EAAcwB,MAAd,EAAsBtB,GAAtB,EAA2BU,UAA3B,CAAnB;AACA,SAAOA,UAAP;AACD;;AAED,SAASI,mBAAT,CAA6BP,KAA7B,EAAoCe,MAApC,EAA4CtB,GAA5C,EAAiDxB,KAAjD,EAAwD;AACtD,MAAI,CAAC8C,MAAM,CAACE,UAAP,EAAL,EAA0BF,MAAM,CAACG,OAAP;AAC1B,MAAIP,WAAW,GAAGX,KAAK,CAACY,GAAN,CAAUnB,GAAV,CAAlB;AACAsB,EAAAA,MAAM,CAACI,UAAP;;AAEA,UAAQJ,MAAM,CAACK,IAAP,EAAR;AACE,SAAK,SAAL;AACET,MAAAA,WAAW,GAAG,CAAC;AACb1C,QAAAA,KADa;AAEb8B,QAAAA,KAAK,EAAEhB;AAFM,OAAD,CAAd;AAIAiB,MAAAA,KAAK,CAACqB,GAAN,CAAU5B,GAAV,EAAekB,WAAf;AACA;;AAEF,SAAK,YAAL;AACEA,MAAAA,WAAW,GAAG,CAAC;AACb1C,QAAAA,KADa;AAEb8B,QAAAA,KAAK,EAAEgB,MAAM,CAACO,SAAP;AAFM,OAAD,CAAd;AAIAtB,MAAAA,KAAK,CAACqB,GAAN,CAAU5B,GAAV,EAAekB,WAAf;AACA;;AAEF,SAAK,OAAL;AACE,UAAIA,WAAJ,EAAiB;AACfA,QAAAA,WAAW,CAACY,IAAZ,CAAiB;AACftD,UAAAA,KADe;AAEf8B,UAAAA,KAAK,EAAEgB,MAAM,CAACO,SAAP;AAFQ,SAAjB;AAID,OALD,MAKO;AACLX,QAAAA,WAAW,GAAG,CAAC;AACb1C,UAAAA,KADa;AAEb8B,UAAAA,KAAK,EAAEgB,MAAM,CAACO,SAAP;AAFM,SAAD,CAAd;AAIAtB,QAAAA,KAAK,CAACqB,GAAN,CAAU5B,GAAV,EAAekB,WAAf;AACD;;AA7BL;AAgCD;;AAED,MAAMV,iBAAN,CAAwB;AACtBuB,EAAAA,WAAW,CAAChD,IAAD,EAAO;AAChB,SAAKiD,OAAL,GAAe,IAAf;AACA,SAAKC,MAAL,GAAc,KAAd;AACA,SAAKC,QAAL,GAAgB,KAAhB;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,KAAL,GAAa,KAAK,CAAlB;AACA,SAAKA,KAAL,GAAavD,IAAb;AACD;;AAEDwD,EAAAA,MAAM,GAAG;AACP,WAAOC,sBAAsB,CAAC,IAAD,CAA7B;AACD;;AAEDb,EAAAA,IAAI,GAAG;AACL,QAAI,KAAKM,MAAT,EAAiB,OAAO,OAAP;AACjB,QAAI,KAAKC,QAAT,EAAmB,OAAO,SAAP;AACnB,QAAI,KAAKC,WAAT,EAAsB,OAAO,YAAP;AACtB,WAAO,OAAP;AACD;;AAEDV,EAAAA,OAAO,GAAG;AACR,QAAI,CAAC,KAAKO,OAAV,EAAmB;AACjB,YAAM,IAAIS,KAAJ,CAAU,uDAAV,CAAN;AACD;;AAED,QAAI,KAAKR,MAAT,EAAiB;AACf,YAAM,IAAIQ,KAAJ,CAAU,mDAAV,CAAN;AACD;;AAED,SAAKP,QAAL,GAAgB,IAAhB;AACA,SAAKE,WAAL,GAAmB,IAAnB;AACD;;AAEDM,EAAAA,KAAK,GAAG;AACN,QAAI,CAAC,KAAKV,OAAV,EAAmB;AACjB,YAAM,IAAIS,KAAJ,CAAU,uDAAV,CAAN;AACD;;AAED,QAAI,KAAKP,QAAT,EAAmB;AACjB,YAAM,IAAIO,KAAJ,CAAU,qDAAV,CAAN;AACD;;AAED,SAAKR,MAAL,GAAc,IAAd;AACA,SAAKG,WAAL,GAAmB,IAAnB;AACD;;AAEDO,EAAAA,KAAK,CAACpD,OAAD,EAAU;AACb,QAAI,CAAC,KAAKyC,OAAV,EAAmB;AACjB,YAAM,IAAIS,KAAJ,CAAU,uDAAV,CAAN;AACD;;AAED,QAAI,KAAKR,MAAL,IAAe,KAAKC,QAAxB,EAAkC;AAChC,YAAM,IAAIO,KAAJ,CAAU,+DAAV,CAAN;AACD;;AAED,SAAKL,WAAL,GAAmB,IAAnB;AACA,UAAMQ,GAAG,GAAGrD,OAAO,CAAC,KAAK+C,KAAN,CAAnB;AACA,UAAMO,EAAE,GAAG,CAAC,GAAG5D,MAAM,CAAC6D,UAAX,EAAuBvD,OAAvB,EAAiC,wFAAjC,CAAX;;AAEA,QAAI,CAAC,GAAGN,MAAM,CAAC8D,UAAX,EAAuBH,GAAvB,CAAJ,EAAiC;AAC/B,aAAOA,GAAG,CAACI,IAAJ,CAASJ,GAAG,IAAI;AACrB,aAAKP,MAAL,CAAYP,IAAZ,CAAiB,CAACc,GAAD,EAAMC,EAAN,CAAjB;;AAEA,eAAOD,GAAP;AACD,OAJM,CAAP;AAKD;;AAED,SAAKP,MAAL,CAAYP,IAAZ,CAAiB,CAACc,GAAD,EAAMC,EAAN,CAAjB;;AAEA,WAAOD,GAAP;AACD;;AAEDK,EAAAA,UAAU,CAAC1D,OAAD,EAAU;AAClB,SAAK4C,WAAL,GAAmB,IAAnB;AACA,WAAO,KAAKQ,KAAL,CAAWpD,OAAX,CAAP;AACD;;AAEDsC,EAAAA,SAAS,GAAG;AACV,UAAMqB,KAAK,GAAG,KAAKb,MAAnB;AACA,WAAO,WAAWtD,IAAX,EAAiB;AACtB,WAAK,MAAM,CAAC6D,GAAD,EAAMC,EAAN,CAAX,IAAwBK,KAAxB,EAA+B;AAC7B,YAAIN,GAAG,MAAM,OAAOC,EAAE,CAAC9D,IAAD,CAAf,CAAP,EAA+B,OAAO,KAAP;AAChC;;AAED,aAAO,IAAP;AACD,KAND;AAOD;;AAED2C,EAAAA,UAAU,GAAG;AACX,SAAKM,OAAL,GAAe,KAAf;AACD;;AAEDR,EAAAA,UAAU,GAAG;AACX,WAAO,KAAKY,WAAZ;AACD;;AAjGqB;;AAqGxB,SAASI,sBAAT,CAAgCjC,KAAhC,EAAuC;AACrC,WAAS4C,OAAT,CAAiBC,GAAjB,EAAsB;AACpB,QAAI,OAAOA,GAAP,KAAe,SAAnB,EAA8B;AAC5B,UAAIA,GAAJ,EAAS7C,KAAK,CAACkB,OAAN,GAAT,KAA8BlB,KAAK,CAACmC,KAAN;AAC9B;AACD;;AAED,WAAOnC,KAAK,CAACoC,KAAN,CAAY,MAAM9D,gBAAgB,CAACuE,GAAG,EAAJ,CAAlC,CAAP;AACD;;AAEDD,EAAAA,OAAO,CAAC1B,OAAR,GAAkB,MAAMlB,KAAK,CAACkB,OAAN,EAAxB;;AAEA0B,EAAAA,OAAO,CAACT,KAAR,GAAgB,MAAMnC,KAAK,CAACmC,KAAN,EAAtB;;AAEAS,EAAAA,OAAO,CAACR,KAAR,GAAgBU,EAAE,IAAI9C,KAAK,CAACoC,KAAN,CAAY,MAAM9D,gBAAgB,CAACwE,EAAE,EAAH,CAAlC,CAAtB;;AAEAF,EAAAA,OAAO,CAACF,UAAR,GAAqBI,EAAE,IAAI9C,KAAK,CAAC0C,UAAN,CAAiB,MAAMpE,gBAAgB,CAACwE,EAAE,EAAH,CAAvC,CAA3B;;AAEA,SAAOF,OAAP;AACD;;AAED,SAAStE,gBAAT,CAA0BL,KAA1B,EAAiC;AAC/B,MAAI,CAAC,GAAGS,MAAM,CAAC8D,UAAX,EAAuBvE,KAAvB,CAAJ,EAAmC;AACjC,UAAM,IAAIiE,KAAJ,CAAW,iDAAD,GAAqD,wDAArD,GAAgH,6CAAhH,GAAgK,oEAAhK,GAAuO,iFAAjP,CAAN;AACD;;AAED,MAAIjE,KAAK,IAAI,IAAT,IAAiB,OAAOA,KAAP,KAAiB,QAAlC,IAA8C,OAAOA,KAAP,KAAiB,SAA/D,IAA4E,OAAOA,KAAP,KAAiB,QAAjG,EAA2G;AACzG,UAAM,IAAIiE,KAAJ,CAAU,wEAAV,CAAN;AACD;;AAED,SAAOjE,KAAP;AACD;;AAED,MAAM+C,IAAN,CAAW;AACTQ,EAAAA,WAAW,GAAG;AACZ,SAAKuB,QAAL,GAAgB,KAAhB;AACA,SAAKjC,OAAL,GAAe,KAAK,CAApB;AACA,SAAKkC,QAAL,GAAgB,KAAK,CAArB;AACA,SAAKlC,OAAL,GAAe,IAAImC,OAAJ,CAAYC,OAAO,IAAI;AACpC,WAAKF,QAAL,GAAgBE,OAAhB;AACD,KAFc,CAAf;AAGD;;AAEDzC,EAAAA,OAAO,CAACxC,KAAD,EAAQ;AACb,SAAK8E,QAAL,GAAgB,IAAhB;;AAEA,SAAKC,QAAL,CAAc/E,KAAd;AACD;;AAdQ","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.assertSimpleType = assertSimpleType;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nconst synchronize = gen => {\n  return _gensync()(gen).sync;\n};\n\nfunction* genTrue() {\n  return true;\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  const callCacheSync = new CallCache();\n  const callCacheAsync = new CallCache();\n  const futureCache = new CallCache();\n  return function* cachedFunction(arg, data) {\n    const asyncContext = yield* (0, _async.isAsync)();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n    const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);\n    if (cached.valid) return cached.value;\n    const cache = new CacheConfigurator(data);\n    const handlerResult = handler(arg, cache);\n    let finishLock;\n    let value;\n\n    if ((0, _util.isIterableIterator)(handlerResult)) {\n      const gen = handlerResult;\n      value = yield* (0, _async.onFirstPause)(gen, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n\n    updateFunctionCache(callCache, cache, arg, value);\n\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n\n    return value;\n  };\n}\n\nfunction* getCachedValue(cache, arg, data) {\n  const cachedValue = cache.get(arg);\n\n  if (cachedValue) {\n    for (const {\n      value,\n      valid\n    } of cachedValue) {\n      if (yield* valid(data)) return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  const cached = yield* getCachedValue(callCache, arg, data);\n\n  if (cached.valid) {\n    return cached;\n  }\n\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n\n    if (cached.valid) {\n      const value = yield* (0, _async.waitFor)(cached.value.promise);\n      return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  const finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  let cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n\n    this._never = true;\n    this._configured = true;\n  }\n\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._configured = true;\n    const key = handler(this._data);\n    const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);\n\n    if ((0, _async.isThenable)(key)) {\n      return key.then(key => {\n        this._pairs.push([key, fn]);\n\n        return key;\n      });\n    }\n\n    this._pairs.push([key, fn]);\n\n    return key;\n  }\n\n  invalidate(handler) {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n\n  validator() {\n    const pairs = this._pairs;\n    return function* (data) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n\n      return true;\n    };\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n\n}\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n\n  cacheFn.forever = () => cache.forever();\n\n  cacheFn.never = () => cache.never();\n\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nclass Lock {\n  constructor() {\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  release(value) {\n    this.released = true;\n\n    this._resolve(value);\n  }\n\n}"]},"metadata":{},"sourceType":"script"}