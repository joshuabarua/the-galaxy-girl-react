{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.msg = msg;\nexports.access = access;\nexports.assertRootMode = assertRootMode;\nexports.assertSourceMaps = assertSourceMaps;\nexports.assertCompact = assertCompact;\nexports.assertSourceType = assertSourceType;\nexports.assertCallerMetadata = assertCallerMetadata;\nexports.assertInputSourceMap = assertInputSourceMap;\nexports.assertString = assertString;\nexports.assertFunction = assertFunction;\nexports.assertBoolean = assertBoolean;\nexports.assertObject = assertObject;\nexports.assertArray = assertArray;\nexports.assertIgnoreList = assertIgnoreList;\nexports.assertConfigApplicableTest = assertConfigApplicableTest;\nexports.assertConfigFileSearch = assertConfigFileSearch;\nexports.assertBabelrcSearch = assertBabelrcSearch;\nexports.assertPluginList = assertPluginList;\nexports.assertTargets = assertTargets;\nexports.assertAssumptions = assertAssumptions;\n\nfunction _helperCompilationTargets() {\n  const data = require(\"@babel/helper-compilation-targets\");\n\n  _helperCompilationTargets = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./options\");\n\nfunction msg(loc) {\n  switch (loc.type) {\n    case \"root\":\n      return ``;\n\n    case \"env\":\n      return `${msg(loc.parent)}.env[\"${loc.name}\"]`;\n\n    case \"overrides\":\n      return `${msg(loc.parent)}.overrides[${loc.index}]`;\n\n    case \"option\":\n      return `${msg(loc.parent)}.${loc.name}`;\n\n    case \"access\":\n      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;\n\n    default:\n      throw new Error(`Assertion failure: Unknown type ${loc.type}`);\n  }\n}\n\nfunction access(loc, name) {\n  return {\n    type: \"access\",\n    name,\n    parent: loc\n  };\n}\n\nfunction assertRootMode(loc, value) {\n  if (value !== undefined && value !== \"root\" && value !== \"upward\" && value !== \"upward-optional\") {\n    throw new Error(`${msg(loc)} must be a \"root\", \"upward\", \"upward-optional\" or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceMaps(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"inline\" && value !== \"both\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"inline\", \"both\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCompact(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"auto\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceType(loc, value) {\n  if (value !== undefined && value !== \"module\" && value !== \"script\" && value !== \"unambiguous\") {\n    throw new Error(`${msg(loc)} must be \"module\", \"script\", \"unambiguous\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCallerMetadata(loc, value) {\n  const obj = assertObject(loc, value);\n\n  if (obj) {\n    if (typeof obj.name !== \"string\") {\n      throw new Error(`${msg(loc)} set but does not contain \"name\" property string`);\n    }\n\n    for (const prop of Object.keys(obj)) {\n      const propLoc = access(loc, prop);\n      const value = obj[prop];\n\n      if (value != null && typeof value !== \"boolean\" && typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction assertInputSourceMap(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && (typeof value !== \"object\" || !value)) {\n    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertString(loc, value) {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a string, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertFunction(loc, value) {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a function, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertBoolean(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(`${msg(loc)} must be a boolean, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertObject(loc, value) {\n  if (value !== undefined && (typeof value !== \"object\" || Array.isArray(value) || !value)) {\n    throw new Error(`${msg(loc)} must be an object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertArray(loc, value) {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be an array, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertIgnoreList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertIgnoreItem(loc, value) {\n  if (typeof value !== \"string\" && typeof value !== \"function\" && !(value instanceof RegExp)) {\n    throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertConfigApplicableTest(loc, value) {\n  if (value === undefined) return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);\n  }\n\n  return value;\n}\n\nfunction checkValidTest(value) {\n  return typeof value === \"string\" || typeof value === \"function\" || value instanceof RegExp;\n}\n\nfunction assertConfigFileSearch(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, ` + `got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertBabelrcSearch(loc, value) {\n  if (value === undefined || typeof value === \"boolean\") return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` + `or an array of those, got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertPluginList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertPluginItem(loc, value) {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(`${msg(loc)} must include an object`);\n    }\n\n    if (value.length > 3) {\n      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);\n    }\n\n    assertPluginTarget(access(loc, 0), value[0]);\n\n    if (value.length > 1) {\n      const opts = value[1];\n\n      if (opts !== undefined && opts !== false && (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)) {\n        throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);\n      }\n    }\n\n    if (value.length === 3) {\n      const name = value[2];\n\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n\n  return value;\n}\n\nfunction assertPluginTarget(loc, value) {\n  if ((typeof value !== \"object\" || !value) && typeof value !== \"string\" && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a string, object, function`);\n  }\n\n  return value;\n}\n\nfunction assertTargets(loc, value) {\n  if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value)) return value;\n\n  if (typeof value !== \"object\" || !value || Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);\n  }\n\n  const browsersLoc = access(loc, \"browsers\");\n  const esmodulesLoc = access(loc, \"esmodules\");\n  assertBrowsersList(browsersLoc, value.browsers);\n  assertBoolean(esmodulesLoc, value.esmodules);\n\n  for (const key of Object.keys(value)) {\n    const val = value[key];\n    const subLoc = access(loc, key);\n    if (key === \"esmodules\") assertBoolean(subLoc, val);else if (key === \"browsers\") assertBrowsersList(subLoc, val);else if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {\n      const validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(\", \");\n      throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);\n    } else assertBrowserVersion(subLoc, val);\n  }\n\n  return value;\n}\n\nfunction assertBrowsersList(loc, value) {\n  if (value !== undefined && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value)) {\n    throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`);\n  }\n}\n\nfunction assertBrowserVersion(loc, value) {\n  if (typeof value === \"number\" && Math.round(value) === value) return;\n  if (typeof value === \"string\") return;\n  throw new Error(`${msg(loc)} must be a string or an integer number`);\n}\n\nfunction assertAssumptions(loc, value) {\n  if (value === undefined) return;\n\n  if (typeof value !== \"object\" || value === null) {\n    throw new Error(`${msg(loc)} must be an object or undefined.`);\n  }\n\n  let root = loc;\n\n  do {\n    root = root.parent;\n  } while (root.type !== \"root\");\n\n  const inPreset = root.source === \"preset\";\n\n  for (const name of Object.keys(value)) {\n    const subLoc = access(loc, name);\n\n    if (!_options.assumptionsNames.has(name)) {\n      throw new Error(`${msg(subLoc)} is not a supported assumption.`);\n    }\n\n    if (typeof value[name] !== \"boolean\") {\n      throw new Error(`${msg(subLoc)} must be a boolean.`);\n    }\n\n    if (inPreset && value[name] === false) {\n      throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`);\n    }\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/Users/josh/Projects/GalaxyGirl/g-girl/node_modules/@babel/core/lib/config/validation/option-assertions.js"],"names":["Object","defineProperty","exports","value","msg","access","assertRootMode","assertSourceMaps","assertCompact","assertSourceType","assertCallerMetadata","assertInputSourceMap","assertString","assertFunction","assertBoolean","assertObject","assertArray","assertIgnoreList","assertConfigApplicableTest","assertConfigFileSearch","assertBabelrcSearch","assertPluginList","assertTargets","assertAssumptions","_helperCompilationTargets","data","require","_options","loc","type","parent","name","index","JSON","stringify","Error","undefined","obj","prop","keys","propLoc","Array","isArray","arr","forEach","item","i","assertIgnoreItem","RegExp","checkValidTest","assertPluginItem","length","assertPluginTarget","opts","isBrowsersQueryValid","browsersLoc","esmodulesLoc","assertBrowsersList","browsers","esmodules","key","val","subLoc","hasOwnProperty","call","TargetNames","validTargets","join","assertBrowserVersion","Math","round","root","inPreset","source","assumptionsNames","has"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.msg = msg;\nexports.access = access;\nexports.assertRootMode = assertRootMode;\nexports.assertSourceMaps = assertSourceMaps;\nexports.assertCompact = assertCompact;\nexports.assertSourceType = assertSourceType;\nexports.assertCallerMetadata = assertCallerMetadata;\nexports.assertInputSourceMap = assertInputSourceMap;\nexports.assertString = assertString;\nexports.assertFunction = assertFunction;\nexports.assertBoolean = assertBoolean;\nexports.assertObject = assertObject;\nexports.assertArray = assertArray;\nexports.assertIgnoreList = assertIgnoreList;\nexports.assertConfigApplicableTest = assertConfigApplicableTest;\nexports.assertConfigFileSearch = assertConfigFileSearch;\nexports.assertBabelrcSearch = assertBabelrcSearch;\nexports.assertPluginList = assertPluginList;\nexports.assertTargets = assertTargets;\nexports.assertAssumptions = assertAssumptions;\n\nfunction _helperCompilationTargets() {\n  const data = require(\"@babel/helper-compilation-targets\");\n\n  _helperCompilationTargets = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./options\");\n\nfunction msg(loc) {\n  switch (loc.type) {\n    case \"root\":\n      return ``;\n\n    case \"env\":\n      return `${msg(loc.parent)}.env[\"${loc.name}\"]`;\n\n    case \"overrides\":\n      return `${msg(loc.parent)}.overrides[${loc.index}]`;\n\n    case \"option\":\n      return `${msg(loc.parent)}.${loc.name}`;\n\n    case \"access\":\n      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;\n\n    default:\n      throw new Error(`Assertion failure: Unknown type ${loc.type}`);\n  }\n}\n\nfunction access(loc, name) {\n  return {\n    type: \"access\",\n    name,\n    parent: loc\n  };\n}\n\nfunction assertRootMode(loc, value) {\n  if (value !== undefined && value !== \"root\" && value !== \"upward\" && value !== \"upward-optional\") {\n    throw new Error(`${msg(loc)} must be a \"root\", \"upward\", \"upward-optional\" or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceMaps(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"inline\" && value !== \"both\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"inline\", \"both\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCompact(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"auto\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceType(loc, value) {\n  if (value !== undefined && value !== \"module\" && value !== \"script\" && value !== \"unambiguous\") {\n    throw new Error(`${msg(loc)} must be \"module\", \"script\", \"unambiguous\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCallerMetadata(loc, value) {\n  const obj = assertObject(loc, value);\n\n  if (obj) {\n    if (typeof obj.name !== \"string\") {\n      throw new Error(`${msg(loc)} set but does not contain \"name\" property string`);\n    }\n\n    for (const prop of Object.keys(obj)) {\n      const propLoc = access(loc, prop);\n      const value = obj[prop];\n\n      if (value != null && typeof value !== \"boolean\" && typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction assertInputSourceMap(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && (typeof value !== \"object\" || !value)) {\n    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertString(loc, value) {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a string, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertFunction(loc, value) {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a function, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertBoolean(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(`${msg(loc)} must be a boolean, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertObject(loc, value) {\n  if (value !== undefined && (typeof value !== \"object\" || Array.isArray(value) || !value)) {\n    throw new Error(`${msg(loc)} must be an object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertArray(loc, value) {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be an array, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertIgnoreList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertIgnoreItem(loc, value) {\n  if (typeof value !== \"string\" && typeof value !== \"function\" && !(value instanceof RegExp)) {\n    throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertConfigApplicableTest(loc, value) {\n  if (value === undefined) return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);\n  }\n\n  return value;\n}\n\nfunction checkValidTest(value) {\n  return typeof value === \"string\" || typeof value === \"function\" || value instanceof RegExp;\n}\n\nfunction assertConfigFileSearch(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, ` + `got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertBabelrcSearch(loc, value) {\n  if (value === undefined || typeof value === \"boolean\") return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` + `or an array of those, got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertPluginList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertPluginItem(loc, value) {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(`${msg(loc)} must include an object`);\n    }\n\n    if (value.length > 3) {\n      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);\n    }\n\n    assertPluginTarget(access(loc, 0), value[0]);\n\n    if (value.length > 1) {\n      const opts = value[1];\n\n      if (opts !== undefined && opts !== false && (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)) {\n        throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);\n      }\n    }\n\n    if (value.length === 3) {\n      const name = value[2];\n\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n\n  return value;\n}\n\nfunction assertPluginTarget(loc, value) {\n  if ((typeof value !== \"object\" || !value) && typeof value !== \"string\" && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a string, object, function`);\n  }\n\n  return value;\n}\n\nfunction assertTargets(loc, value) {\n  if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value)) return value;\n\n  if (typeof value !== \"object\" || !value || Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);\n  }\n\n  const browsersLoc = access(loc, \"browsers\");\n  const esmodulesLoc = access(loc, \"esmodules\");\n  assertBrowsersList(browsersLoc, value.browsers);\n  assertBoolean(esmodulesLoc, value.esmodules);\n\n  for (const key of Object.keys(value)) {\n    const val = value[key];\n    const subLoc = access(loc, key);\n    if (key === \"esmodules\") assertBoolean(subLoc, val);else if (key === \"browsers\") assertBrowsersList(subLoc, val);else if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {\n      const validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(\", \");\n      throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);\n    } else assertBrowserVersion(subLoc, val);\n  }\n\n  return value;\n}\n\nfunction assertBrowsersList(loc, value) {\n  if (value !== undefined && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value)) {\n    throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`);\n  }\n}\n\nfunction assertBrowserVersion(loc, value) {\n  if (typeof value === \"number\" && Math.round(value) === value) return;\n  if (typeof value === \"string\") return;\n  throw new Error(`${msg(loc)} must be a string or an integer number`);\n}\n\nfunction assertAssumptions(loc, value) {\n  if (value === undefined) return;\n\n  if (typeof value !== \"object\" || value === null) {\n    throw new Error(`${msg(loc)} must be an object or undefined.`);\n  }\n\n  let root = loc;\n\n  do {\n    root = root.parent;\n  } while (root.type !== \"root\");\n\n  const inPreset = root.source === \"preset\";\n\n  for (const name of Object.keys(value)) {\n    const subLoc = access(loc, name);\n\n    if (!_options.assumptionsNames.has(name)) {\n      throw new Error(`${msg(subLoc)} is not a supported assumption.`);\n    }\n\n    if (typeof value[name] !== \"boolean\") {\n      throw new Error(`${msg(subLoc)} must be a boolean.`);\n    }\n\n    if (inPreset && value[name] === false) {\n      throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`);\n    }\n  }\n\n  return value;\n}"]},"metadata":{},"sourceType":"script"}