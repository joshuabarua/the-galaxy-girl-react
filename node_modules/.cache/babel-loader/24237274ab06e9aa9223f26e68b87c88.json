{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = require(\"@babel/types\");\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", t.FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    callee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(t.awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    callee.set(\"generator\", true);\n    this.replaceWith(t.yieldExpression(this.node, true));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","map":{"version":3,"sources":["/Users/josh/Projects/GalaxyGirl/g-girl/node_modules/@babel/traverse/lib/path/replacement.js"],"names":["Object","defineProperty","exports","value","replaceWithMultiple","replaceWithSourceString","replaceWith","_replaceWith","replaceExpressionWithStatements","replaceInline","_codeFrame","require","_index","_index2","_cache","_parser","t","hoistVariablesVisitor","Function","path","skip","VariableDeclaration","node","kind","bindings","getBindingIdentifiers","key","keys","scope","push","id","exprs","declar","declarations","init","expressionStatement","assignmentExpression","nodes","_pathCache$get","resync","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","length","get","parent","delete","container","paths","insertAfter","requeue","remove","replacement","parse","err","loc","message","codeFrameColumns","start","line","column","code","program","body","expression","default","removeProperties","removed","Error","isProgram","Array","isArray","nodePath","isNodeType","isExpression","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","parentPath","isExportDefaultDeclaration","isStatement","oldNode","inheritsComments","removeComments","type","setScope","_pathCache$get2","ReferenceError","inList","validate","debug","set","toSequenceExpression","functionParent","getFunctionParent","isParentAsync","is","isParentGenerator","arrowFunctionExpression","blockStatement","callExpression","traverse","completionRecords","getCompletionRecords","isExpressionStatement","loop","findParent","isLoop","uid","getData","callee","generateDeclaredUidIdentifier","pushContainer","returnStatement","cloneNode","setData","identifier","name","arrowFunctionToExpression","needToAwaitFunction","hasType","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","_containerInsertAfter"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = require(\"@babel/types\");\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", t.FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    callee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(t.awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    callee.set(\"generator\", true);\n    this.replaceWith(t.yieldExpression(this.node, true));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}"]},"metadata":{},"sourceType":"script"}