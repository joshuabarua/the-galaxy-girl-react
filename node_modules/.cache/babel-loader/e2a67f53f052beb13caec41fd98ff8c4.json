{"ast":null,"code":"import { PureComponent } from 'react';\n\nfunction isInteger(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n\nfunction isRangeVisible(_ref) {\n  var lastRenderedStartIndex = _ref.lastRenderedStartIndex,\n      lastRenderedStopIndex = _ref.lastRenderedStopIndex,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\nfunction scanForUnloadedRanges(_ref) {\n  var isItemLoaded = _ref.isItemLoaded,\n      itemCount = _ref.itemCount,\n      minimumBatchSize = _ref.minimumBatchSize,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n  var unloadedRanges = [];\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n\n  for (var _index = startIndex; _index <= stopIndex; _index++) {\n    var loaded = isItemLoaded(_index);\n\n    if (!loaded) {\n      rangeStopIndex = _index;\n\n      if (rangeStartIndex === null) {\n        rangeStartIndex = _index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  } // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n\n\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), itemCount - 1);\n\n    for (var _index2 = rangeStopIndex + 1; _index2 <= potentialStopIndex; _index2++) {\n      if (!isItemLoaded(_index2)) {\n        rangeStopIndex = _index2;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n  } // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n\n\n  if (unloadedRanges.length) {\n    while (unloadedRanges[1] - unloadedRanges[0] + 1 < minimumBatchSize && unloadedRanges[0] > 0) {\n      var _index3 = unloadedRanges[0] - 1;\n\n      if (!isItemLoaded(_index3)) {\n        unloadedRanges[0] = _index3;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar InfiniteLoader = function (_PureComponent) {\n  inherits(InfiniteLoader, _PureComponent);\n\n  function InfiniteLoader() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, InfiniteLoader);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = InfiniteLoader.__proto__ || Object.getPrototypeOf(InfiniteLoader)).call.apply(_ref, [this].concat(args))), _this), _this._lastRenderedStartIndex = -1, _this._lastRenderedStopIndex = -1, _this._memoizedUnloadedRanges = [], _this._onItemsRendered = function (_ref2) {\n      var visibleStartIndex = _ref2.visibleStartIndex,\n          visibleStopIndex = _ref2.visibleStopIndex;\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!isInteger(visibleStartIndex) || !isInteger(visibleStopIndex)) {\n          console.warn('Invalid onItemsRendered signature; please refer to InfiniteLoader documentation.');\n        }\n\n        if (typeof _this.props.loadMoreRows === 'function') {\n          console.warn('InfiniteLoader \"loadMoreRows\" prop has been renamed to \"loadMoreItems\".');\n        }\n      }\n\n      _this._lastRenderedStartIndex = visibleStartIndex;\n      _this._lastRenderedStopIndex = visibleStopIndex;\n\n      _this._ensureRowsLoaded(visibleStartIndex, visibleStopIndex);\n    }, _this._setRef = function (listRef) {\n      _this._listRef = listRef;\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(InfiniteLoader, [{\n    key: 'resetloadMoreItemsCache',\n    value: function resetloadMoreItemsCache() {\n      var autoReload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this._memoizedUnloadedRanges = [];\n\n      if (autoReload) {\n        this._ensureRowsLoaded(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this._listRef == null) {\n          console.warn('Invalid list ref; please refer to InfiniteLoader documentation.');\n        }\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var children = this.props.children;\n      return children({\n        onItemsRendered: this._onItemsRendered,\n        ref: this._setRef\n      });\n    }\n  }, {\n    key: '_ensureRowsLoaded',\n    value: function _ensureRowsLoaded(startIndex, stopIndex) {\n      var _props = this.props,\n          isItemLoaded = _props.isItemLoaded,\n          itemCount = _props.itemCount,\n          _props$minimumBatchSi = _props.minimumBatchSize,\n          minimumBatchSize = _props$minimumBatchSi === undefined ? 10 : _props$minimumBatchSi,\n          _props$threshold = _props.threshold,\n          threshold = _props$threshold === undefined ? 15 : _props$threshold;\n      var unloadedRanges = scanForUnloadedRanges({\n        isItemLoaded: isItemLoaded,\n        itemCount: itemCount,\n        minimumBatchSize: minimumBatchSize,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(itemCount - 1, stopIndex + threshold)\n      }); // Avoid calling load-rows unless range has changed.\n      // This shouldn't be strictly necessary, but is maybe nice to do.\n\n      if (this._memoizedUnloadedRanges.length !== unloadedRanges.length || this._memoizedUnloadedRanges.some(function (startOrStop, index) {\n        return unloadedRanges[index] !== startOrStop;\n      })) {\n        this._memoizedUnloadedRanges = unloadedRanges;\n\n        this._loadUnloadedRanges(unloadedRanges);\n      }\n    }\n  }, {\n    key: '_loadUnloadedRanges',\n    value: function _loadUnloadedRanges(unloadedRanges) {\n      var _this2 = this; // loadMoreRows was renamed to loadMoreItems in v1.0.3; will be removed in v2.0\n\n\n      var loadMoreItems = this.props.loadMoreItems || this.props.loadMoreRows;\n\n      var _loop = function _loop(i) {\n        var startIndex = unloadedRanges[i];\n        var stopIndex = unloadedRanges[i + 1];\n        var promise = loadMoreItems(startIndex, stopIndex);\n\n        if (promise != null) {\n          promise.then(function () {\n            // Refresh the visible rows if any of them have just been loaded.\n            // Otherwise they will remain in their unloaded visual state.\n            if (isRangeVisible({\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\n              startIndex: startIndex,\n              stopIndex: stopIndex\n            })) {\n              // Handle an unmount while promises are still in flight.\n              if (_this2._listRef == null) {\n                return;\n              } // Resize cached row sizes for VariableSizeList,\n              // otherwise just re-render the list.\n\n\n              if (typeof _this2._listRef.resetAfterIndex === 'function') {\n                _this2._listRef.resetAfterIndex(startIndex, true);\n              } else {\n                // HACK reset temporarily cached item styles to force PureComponent to re-render.\n                // This is pretty gross, but I'm okay with it for now.\n                // Don't judge me.\n                if (typeof _this2._listRef._getItemStyleCache === 'function') {\n                  _this2._listRef._getItemStyleCache(-1);\n                }\n\n                _this2._listRef.forceUpdate();\n              }\n            }\n          });\n        }\n      };\n\n      for (var i = 0; i < unloadedRanges.length; i += 2) {\n        _loop(i);\n      }\n    }\n  }]);\n  return InfiniteLoader;\n}(PureComponent);\n\nexport default InfiniteLoader;","map":{"version":3,"sources":["/Users/josh/Projects/GalaxyGirl/g-girl/node_modules/react-window-infinite-loader/dist/index.esm.js"],"names":["PureComponent","isInteger","value","isFinite","Math","floor","isRangeVisible","_ref","lastRenderedStartIndex","lastRenderedStopIndex","startIndex","stopIndex","scanForUnloadedRanges","isItemLoaded","itemCount","minimumBatchSize","unloadedRanges","rangeStartIndex","rangeStopIndex","_index","loaded","push","potentialStopIndex","min","max","_index2","length","_index3","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","i","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","possibleConstructorReturn","self","call","ReferenceError","InfiniteLoader","_PureComponent","_temp","_this","_ret","_len","arguments","args","Array","_key","getPrototypeOf","apply","concat","_lastRenderedStartIndex","_lastRenderedStopIndex","_memoizedUnloadedRanges","_onItemsRendered","_ref2","visibleStartIndex","visibleStopIndex","process","env","NODE_ENV","console","warn","loadMoreRows","_ensureRowsLoaded","_setRef","listRef","_listRef","resetloadMoreItemsCache","autoReload","undefined","componentDidMount","render","children","onItemsRendered","ref","_props","_props$minimumBatchSi","_props$threshold","threshold","some","startOrStop","index","_loadUnloadedRanges","_this2","loadMoreItems","_loop","promise","then","resetAfterIndex","_getItemStyleCache","forceUpdate"],"mappings":"AAAA,SAASA,aAAT,QAA8B,OAA9B;;AAEA,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACxB,SAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6BC,QAAQ,CAACD,KAAD,CAArC,IAAgDE,IAAI,CAACC,KAAL,CAAWH,KAAX,MAAsBA,KAA7E;AACD;;AAED,SAASI,cAAT,CAAwBC,IAAxB,EAA8B;AAC5B,MAAIC,sBAAsB,GAAGD,IAAI,CAACC,sBAAlC;AAAA,MACIC,qBAAqB,GAAGF,IAAI,CAACE,qBADjC;AAAA,MAEIC,UAAU,GAAGH,IAAI,CAACG,UAFtB;AAAA,MAGIC,SAAS,GAAGJ,IAAI,CAACI,SAHrB;AAKA,SAAO,EAAED,UAAU,GAAGD,qBAAb,IAAsCE,SAAS,GAAGH,sBAApD,CAAP;AACD;;AAED,SAASI,qBAAT,CAA+BL,IAA/B,EAAqC;AACnC,MAAIM,YAAY,GAAGN,IAAI,CAACM,YAAxB;AAAA,MACIC,SAAS,GAAGP,IAAI,CAACO,SADrB;AAAA,MAEIC,gBAAgB,GAAGR,IAAI,CAACQ,gBAF5B;AAAA,MAGIL,UAAU,GAAGH,IAAI,CAACG,UAHtB;AAAA,MAIIC,SAAS,GAAGJ,IAAI,CAACI,SAJrB;AAMA,MAAIK,cAAc,GAAG,EAArB;AAEA,MAAIC,eAAe,GAAG,IAAtB;AACA,MAAIC,cAAc,GAAG,IAArB;;AAEA,OAAK,IAAIC,MAAM,GAAGT,UAAlB,EAA8BS,MAAM,IAAIR,SAAxC,EAAmDQ,MAAM,EAAzD,EAA6D;AAC3D,QAAIC,MAAM,GAAGP,YAAY,CAACM,MAAD,CAAzB;;AAEA,QAAI,CAACC,MAAL,EAAa;AACXF,MAAAA,cAAc,GAAGC,MAAjB;;AACA,UAAIF,eAAe,KAAK,IAAxB,EAA8B;AAC5BA,QAAAA,eAAe,GAAGE,MAAlB;AACD;AACF,KALD,MAKO,IAAID,cAAc,KAAK,IAAvB,EAA6B;AAClCF,MAAAA,cAAc,CAACK,IAAf,CAAoBJ,eAApB,EAAqCC,cAArC;AAEAD,MAAAA,eAAe,GAAGC,cAAc,GAAG,IAAnC;AACD;AACF,GAzBkC,CA2BnC;AACA;;;AACA,MAAIA,cAAc,KAAK,IAAvB,EAA6B;AAC3B,QAAII,kBAAkB,GAAGlB,IAAI,CAACmB,GAAL,CAASnB,IAAI,CAACoB,GAAL,CAASN,cAAT,EAAyBD,eAAe,GAAGF,gBAAlB,GAAqC,CAA9D,CAAT,EAA2ED,SAAS,GAAG,CAAvF,CAAzB;;AAEA,SAAK,IAAIW,OAAO,GAAGP,cAAc,GAAG,CAApC,EAAuCO,OAAO,IAAIH,kBAAlD,EAAsEG,OAAO,EAA7E,EAAiF;AAC/E,UAAI,CAACZ,YAAY,CAACY,OAAD,CAAjB,EAA4B;AAC1BP,QAAAA,cAAc,GAAGO,OAAjB;AACD,OAFD,MAEO;AACL;AACD;AACF;;AAEDT,IAAAA,cAAc,CAACK,IAAf,CAAoBJ,eAApB,EAAqCC,cAArC;AACD,GAzCkC,CA2CnC;AACA;;;AACA,MAAIF,cAAc,CAACU,MAAnB,EAA2B;AACzB,WAAOV,cAAc,CAAC,CAAD,CAAd,GAAoBA,cAAc,CAAC,CAAD,CAAlC,GAAwC,CAAxC,GAA4CD,gBAA5C,IAAgEC,cAAc,CAAC,CAAD,CAAd,GAAoB,CAA3F,EAA8F;AAC5F,UAAIW,OAAO,GAAGX,cAAc,CAAC,CAAD,CAAd,GAAoB,CAAlC;;AAEA,UAAI,CAACH,YAAY,CAACc,OAAD,CAAjB,EAA4B;AAC1BX,QAAAA,cAAc,CAAC,CAAD,CAAd,GAAoBW,OAApB;AACD,OAFD,MAEO;AACL;AACD;AACF;AACF;;AAED,SAAOX,cAAP;AACD;;AAED,IAAIY,cAAc,GAAG,UAAUC,QAAV,EAAoBC,WAApB,EAAiC;AACpD,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AACtC,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AACD;AACF,CAJD;;AAMA,IAAIC,WAAW,GAAG,YAAY;AAC5B,WAASC,gBAAT,CAA0BC,MAA1B,EAAkCC,KAAlC,EAAyC;AACvC,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACT,MAA1B,EAAkCU,CAAC,EAAnC,EAAuC;AACrC,UAAIC,UAAU,GAAGF,KAAK,CAACC,CAAD,CAAtB;AACAC,MAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AACAD,MAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AACA,UAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAC3BC,MAAAA,MAAM,CAACC,cAAP,CAAsBR,MAAtB,EAA8BG,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AACD;AACF;;AAED,SAAO,UAAUP,WAAV,EAAuBc,UAAvB,EAAmCC,WAAnC,EAAgD;AACrD,QAAID,UAAJ,EAAgBX,gBAAgB,CAACH,WAAW,CAACgB,SAAb,EAAwBF,UAAxB,CAAhB;AAChB,QAAIC,WAAJ,EAAiBZ,gBAAgB,CAACH,WAAD,EAAce,WAAd,CAAhB;AACjB,WAAOf,WAAP;AACD,GAJD;AAKD,CAhBiB,EAAlB;;AAkBA,IAAIiB,QAAQ,GAAG,UAAUC,QAAV,EAAoBC,UAApB,EAAgC;AAC7C,MAAI,OAAOA,UAAP,KAAsB,UAAtB,IAAoCA,UAAU,KAAK,IAAvD,EAA6D;AAC3D,UAAM,IAAIlB,SAAJ,CAAc,6DAA6D,OAAOkB,UAAlF,CAAN;AACD;;AAEDD,EAAAA,QAAQ,CAACF,SAAT,GAAqBL,MAAM,CAACS,MAAP,CAAcD,UAAU,IAAIA,UAAU,CAACH,SAAvC,EAAkD;AACrEK,IAAAA,WAAW,EAAE;AACXjD,MAAAA,KAAK,EAAE8C,QADI;AAEXV,MAAAA,UAAU,EAAE,KAFD;AAGXE,MAAAA,QAAQ,EAAE,IAHC;AAIXD,MAAAA,YAAY,EAAE;AAJH;AADwD,GAAlD,CAArB;AAQA,MAAIU,UAAJ,EAAgBR,MAAM,CAACW,cAAP,GAAwBX,MAAM,CAACW,cAAP,CAAsBJ,QAAtB,EAAgCC,UAAhC,CAAxB,GAAsED,QAAQ,CAACK,SAAT,GAAqBJ,UAA3F;AACjB,CAdD;;AAgBA,IAAIK,yBAAyB,GAAG,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AACpD,MAAI,CAACD,IAAL,EAAW;AACT,UAAM,IAAIE,cAAJ,CAAmB,2DAAnB,CAAN;AACD;;AAED,SAAOD,IAAI,KAAK,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,UAAjD,CAAJ,GAAmEA,IAAnE,GAA0ED,IAAjF;AACD,CAND;;AAQA,IAAIG,cAAc,GAAG,UAAUC,cAAV,EAA0B;AAC7CZ,EAAAA,QAAQ,CAACW,cAAD,EAAiBC,cAAjB,CAAR;;AAEA,WAASD,cAAT,GAA0B;AACxB,QAAInD,IAAJ;;AAEA,QAAIqD,KAAJ,EAAWC,KAAX,EAAkBC,IAAlB;;AAEAlC,IAAAA,cAAc,CAAC,IAAD,EAAO8B,cAAP,CAAd;;AAEA,SAAK,IAAIK,IAAI,GAAGC,SAAS,CAACtC,MAArB,EAA6BuC,IAAI,GAAGC,KAAK,CAACH,IAAD,CAAzC,EAAiDI,IAAI,GAAG,CAA7D,EAAgEA,IAAI,GAAGJ,IAAvE,EAA6EI,IAAI,EAAjF,EAAqF;AACnFF,MAAAA,IAAI,CAACE,IAAD,CAAJ,GAAaH,SAAS,CAACG,IAAD,CAAtB;AACD;;AAED,WAAOL,IAAI,IAAIF,KAAK,IAAIC,KAAK,GAAGP,yBAAyB,CAAC,IAAD,EAAO,CAAC/C,IAAI,GAAGmD,cAAc,CAACL,SAAf,IAA4BZ,MAAM,CAAC2B,cAAP,CAAsBV,cAAtB,CAApC,EAA2EF,IAA3E,CAAgFa,KAAhF,CAAsF9D,IAAtF,EAA4F,CAAC,IAAD,EAAO+D,MAAP,CAAcL,IAAd,CAA5F,CAAP,CAAjC,EAA2JJ,KAA/J,CAAL,EAA4KA,KAAK,CAACU,uBAAN,GAAgC,CAAC,CAA7M,EAAgNV,KAAK,CAACW,sBAAN,GAA+B,CAAC,CAAhP,EAAmPX,KAAK,CAACY,uBAAN,GAAgC,EAAnR,EAAuRZ,KAAK,CAACa,gBAAN,GAAyB,UAAUC,KAAV,EAAiB;AAC9U,UAAIC,iBAAiB,GAAGD,KAAK,CAACC,iBAA9B;AAAA,UACIC,gBAAgB,GAAGF,KAAK,CAACE,gBAD7B;;AAGA,UAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,YAAI,CAAC/E,SAAS,CAAC2E,iBAAD,CAAV,IAAiC,CAAC3E,SAAS,CAAC4E,gBAAD,CAA/C,EAAmE;AACjEI,UAAAA,OAAO,CAACC,IAAR,CAAa,kFAAb;AACD;;AAED,YAAI,OAAOrB,KAAK,CAAC1B,KAAN,CAAYgD,YAAnB,KAAoC,UAAxC,EAAoD;AAClDF,UAAAA,OAAO,CAACC,IAAR,CAAa,yEAAb;AACD;AACF;;AAEDrB,MAAAA,KAAK,CAACU,uBAAN,GAAgCK,iBAAhC;AACAf,MAAAA,KAAK,CAACW,sBAAN,GAA+BK,gBAA/B;;AAEAhB,MAAAA,KAAK,CAACuB,iBAAN,CAAwBR,iBAAxB,EAA2CC,gBAA3C;AACD,KAlBc,EAkBZhB,KAAK,CAACwB,OAAN,GAAgB,UAAUC,OAAV,EAAmB;AACpCzB,MAAAA,KAAK,CAAC0B,QAAN,GAAiBD,OAAjB;AACD,KApBc,EAoBZ1B,KApBQ,CAAJ,EAoBIN,yBAAyB,CAACO,KAAD,EAAQC,IAAR,CApBpC;AAqBD;;AAED9B,EAAAA,WAAW,CAAC0B,cAAD,EAAiB,CAAC;AAC3Bf,IAAAA,GAAG,EAAE,yBADsB;AAE3BzC,IAAAA,KAAK,EAAE,SAASsF,uBAAT,GAAmC;AACxC,UAAIC,UAAU,GAAGzB,SAAS,CAACtC,MAAV,GAAmB,CAAnB,IAAwBsC,SAAS,CAAC,CAAD,CAAT,KAAiB0B,SAAzC,GAAqD1B,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAArF;AAEA,WAAKS,uBAAL,GAA+B,EAA/B;;AAEA,UAAIgB,UAAJ,EAAgB;AACd,aAAKL,iBAAL,CAAuB,KAAKb,uBAA5B,EAAqD,KAAKC,sBAA1D;AACD;AACF;AAV0B,GAAD,EAWzB;AACD7B,IAAAA,GAAG,EAAE,mBADJ;AAEDzC,IAAAA,KAAK,EAAE,SAASyF,iBAAT,GAA6B;AAClC,UAAIb,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,YAAI,KAAKO,QAAL,IAAiB,IAArB,EAA2B;AACzBN,UAAAA,OAAO,CAACC,IAAR,CAAa,iEAAb;AACD;AACF;AACF;AARA,GAXyB,EAoBzB;AACDvC,IAAAA,GAAG,EAAE,QADJ;AAEDzC,IAAAA,KAAK,EAAE,SAAS0F,MAAT,GAAkB;AACvB,UAAIC,QAAQ,GAAG,KAAK1D,KAAL,CAAW0D,QAA1B;AAGA,aAAOA,QAAQ,CAAC;AACdC,QAAAA,eAAe,EAAE,KAAKpB,gBADR;AAEdqB,QAAAA,GAAG,EAAE,KAAKV;AAFI,OAAD,CAAf;AAID;AAVA,GApByB,EA+BzB;AACD1C,IAAAA,GAAG,EAAE,mBADJ;AAEDzC,IAAAA,KAAK,EAAE,SAASkF,iBAAT,CAA2B1E,UAA3B,EAAuCC,SAAvC,EAAkD;AACvD,UAAIqF,MAAM,GAAG,KAAK7D,KAAlB;AAAA,UACItB,YAAY,GAAGmF,MAAM,CAACnF,YAD1B;AAAA,UAEIC,SAAS,GAAGkF,MAAM,CAAClF,SAFvB;AAAA,UAGImF,qBAAqB,GAAGD,MAAM,CAACjF,gBAHnC;AAAA,UAIIA,gBAAgB,GAAGkF,qBAAqB,KAAKP,SAA1B,GAAsC,EAAtC,GAA2CO,qBAJlE;AAAA,UAKIC,gBAAgB,GAAGF,MAAM,CAACG,SAL9B;AAAA,UAMIA,SAAS,GAAGD,gBAAgB,KAAKR,SAArB,GAAiC,EAAjC,GAAsCQ,gBANtD;AASA,UAAIlF,cAAc,GAAGJ,qBAAqB,CAAC;AACzCC,QAAAA,YAAY,EAAEA,YAD2B;AAEzCC,QAAAA,SAAS,EAAEA,SAF8B;AAGzCC,QAAAA,gBAAgB,EAAEA,gBAHuB;AAIzCL,QAAAA,UAAU,EAAEN,IAAI,CAACoB,GAAL,CAAS,CAAT,EAAYd,UAAU,GAAGyF,SAAzB,CAJ6B;AAKzCxF,QAAAA,SAAS,EAAEP,IAAI,CAACmB,GAAL,CAAST,SAAS,GAAG,CAArB,EAAwBH,SAAS,GAAGwF,SAApC;AAL8B,OAAD,CAA1C,CAVuD,CAkBvD;AACA;;AACA,UAAI,KAAK1B,uBAAL,CAA6B/C,MAA7B,KAAwCV,cAAc,CAACU,MAAvD,IAAiE,KAAK+C,uBAAL,CAA6B2B,IAA7B,CAAkC,UAAUC,WAAV,EAAuBC,KAAvB,EAA8B;AACnI,eAAOtF,cAAc,CAACsF,KAAD,CAAd,KAA0BD,WAAjC;AACD,OAFoE,CAArE,EAEI;AACF,aAAK5B,uBAAL,GAA+BzD,cAA/B;;AACA,aAAKuF,mBAAL,CAAyBvF,cAAzB;AACD;AACF;AA5BA,GA/ByB,EA4DzB;AACD2B,IAAAA,GAAG,EAAE,qBADJ;AAEDzC,IAAAA,KAAK,EAAE,SAASqG,mBAAT,CAA6BvF,cAA7B,EAA6C;AAClD,UAAIwF,MAAM,GAAG,IAAb,CADkD,CAGlD;;;AACA,UAAIC,aAAa,GAAG,KAAKtE,KAAL,CAAWsE,aAAX,IAA4B,KAAKtE,KAAL,CAAWgD,YAA3D;;AAEA,UAAIuB,KAAK,GAAG,SAASA,KAAT,CAAetE,CAAf,EAAkB;AAC5B,YAAI1B,UAAU,GAAGM,cAAc,CAACoB,CAAD,CAA/B;AACA,YAAIzB,SAAS,GAAGK,cAAc,CAACoB,CAAC,GAAG,CAAL,CAA9B;AACA,YAAIuE,OAAO,GAAGF,aAAa,CAAC/F,UAAD,EAAaC,SAAb,CAA3B;;AACA,YAAIgG,OAAO,IAAI,IAAf,EAAqB;AACnBA,UAAAA,OAAO,CAACC,IAAR,CAAa,YAAY;AACvB;AACA;AACA,gBAAItG,cAAc,CAAC;AACjBE,cAAAA,sBAAsB,EAAEgG,MAAM,CAACjC,uBADd;AAEjB9D,cAAAA,qBAAqB,EAAE+F,MAAM,CAAChC,sBAFb;AAGjB9D,cAAAA,UAAU,EAAEA,UAHK;AAIjBC,cAAAA,SAAS,EAAEA;AAJM,aAAD,CAAlB,EAKI;AACF;AACA,kBAAI6F,MAAM,CAACjB,QAAP,IAAmB,IAAvB,EAA6B;AAC3B;AACD,eAJC,CAMF;AACA;;;AACA,kBAAI,OAAOiB,MAAM,CAACjB,QAAP,CAAgBsB,eAAvB,KAA2C,UAA/C,EAA2D;AACzDL,gBAAAA,MAAM,CAACjB,QAAP,CAAgBsB,eAAhB,CAAgCnG,UAAhC,EAA4C,IAA5C;AACD,eAFD,MAEO;AACL;AACA;AACA;AACA,oBAAI,OAAO8F,MAAM,CAACjB,QAAP,CAAgBuB,kBAAvB,KAA8C,UAAlD,EAA8D;AAC5DN,kBAAAA,MAAM,CAACjB,QAAP,CAAgBuB,kBAAhB,CAAmC,CAAC,CAApC;AACD;;AACDN,gBAAAA,MAAM,CAACjB,QAAP,CAAgBwB,WAAhB;AACD;AACF;AACF,WA5BD;AA6BD;AACF,OAnCD;;AAqCA,WAAK,IAAI3E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,cAAc,CAACU,MAAnC,EAA2CU,CAAC,IAAI,CAAhD,EAAmD;AACjDsE,QAAAA,KAAK,CAACtE,CAAD,CAAL;AACD;AACF;AAhDA,GA5DyB,CAAjB,CAAX;AA8GA,SAAOsB,cAAP;AACD,CApJoB,CAoJnB1D,aApJmB,CAArB;;AAsJA,eAAe0D,cAAf","sourcesContent":["import { PureComponent } from 'react';\n\nfunction isInteger(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n\nfunction isRangeVisible(_ref) {\n  var lastRenderedStartIndex = _ref.lastRenderedStartIndex,\n      lastRenderedStopIndex = _ref.lastRenderedStopIndex,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\nfunction scanForUnloadedRanges(_ref) {\n  var isItemLoaded = _ref.isItemLoaded,\n      itemCount = _ref.itemCount,\n      minimumBatchSize = _ref.minimumBatchSize,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  var unloadedRanges = [];\n\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n\n  for (var _index = startIndex; _index <= stopIndex; _index++) {\n    var loaded = isItemLoaded(_index);\n\n    if (!loaded) {\n      rangeStopIndex = _index;\n      if (rangeStartIndex === null) {\n        rangeStartIndex = _index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), itemCount - 1);\n\n    for (var _index2 = rangeStopIndex + 1; _index2 <= potentialStopIndex; _index2++) {\n      if (!isItemLoaded(_index2)) {\n        rangeStopIndex = _index2;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  if (unloadedRanges.length) {\n    while (unloadedRanges[1] - unloadedRanges[0] + 1 < minimumBatchSize && unloadedRanges[0] > 0) {\n      var _index3 = unloadedRanges[0] - 1;\n\n      if (!isItemLoaded(_index3)) {\n        unloadedRanges[0] = _index3;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar InfiniteLoader = function (_PureComponent) {\n  inherits(InfiniteLoader, _PureComponent);\n\n  function InfiniteLoader() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, InfiniteLoader);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = InfiniteLoader.__proto__ || Object.getPrototypeOf(InfiniteLoader)).call.apply(_ref, [this].concat(args))), _this), _this._lastRenderedStartIndex = -1, _this._lastRenderedStopIndex = -1, _this._memoizedUnloadedRanges = [], _this._onItemsRendered = function (_ref2) {\n      var visibleStartIndex = _ref2.visibleStartIndex,\n          visibleStopIndex = _ref2.visibleStopIndex;\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!isInteger(visibleStartIndex) || !isInteger(visibleStopIndex)) {\n          console.warn('Invalid onItemsRendered signature; please refer to InfiniteLoader documentation.');\n        }\n\n        if (typeof _this.props.loadMoreRows === 'function') {\n          console.warn('InfiniteLoader \"loadMoreRows\" prop has been renamed to \"loadMoreItems\".');\n        }\n      }\n\n      _this._lastRenderedStartIndex = visibleStartIndex;\n      _this._lastRenderedStopIndex = visibleStopIndex;\n\n      _this._ensureRowsLoaded(visibleStartIndex, visibleStopIndex);\n    }, _this._setRef = function (listRef) {\n      _this._listRef = listRef;\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(InfiniteLoader, [{\n    key: 'resetloadMoreItemsCache',\n    value: function resetloadMoreItemsCache() {\n      var autoReload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      this._memoizedUnloadedRanges = [];\n\n      if (autoReload) {\n        this._ensureRowsLoaded(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this._listRef == null) {\n          console.warn('Invalid list ref; please refer to InfiniteLoader documentation.');\n        }\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var children = this.props.children;\n\n\n      return children({\n        onItemsRendered: this._onItemsRendered,\n        ref: this._setRef\n      });\n    }\n  }, {\n    key: '_ensureRowsLoaded',\n    value: function _ensureRowsLoaded(startIndex, stopIndex) {\n      var _props = this.props,\n          isItemLoaded = _props.isItemLoaded,\n          itemCount = _props.itemCount,\n          _props$minimumBatchSi = _props.minimumBatchSize,\n          minimumBatchSize = _props$minimumBatchSi === undefined ? 10 : _props$minimumBatchSi,\n          _props$threshold = _props.threshold,\n          threshold = _props$threshold === undefined ? 15 : _props$threshold;\n\n\n      var unloadedRanges = scanForUnloadedRanges({\n        isItemLoaded: isItemLoaded,\n        itemCount: itemCount,\n        minimumBatchSize: minimumBatchSize,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(itemCount - 1, stopIndex + threshold)\n      });\n\n      // Avoid calling load-rows unless range has changed.\n      // This shouldn't be strictly necessary, but is maybe nice to do.\n      if (this._memoizedUnloadedRanges.length !== unloadedRanges.length || this._memoizedUnloadedRanges.some(function (startOrStop, index) {\n        return unloadedRanges[index] !== startOrStop;\n      })) {\n        this._memoizedUnloadedRanges = unloadedRanges;\n        this._loadUnloadedRanges(unloadedRanges);\n      }\n    }\n  }, {\n    key: '_loadUnloadedRanges',\n    value: function _loadUnloadedRanges(unloadedRanges) {\n      var _this2 = this;\n\n      // loadMoreRows was renamed to loadMoreItems in v1.0.3; will be removed in v2.0\n      var loadMoreItems = this.props.loadMoreItems || this.props.loadMoreRows;\n\n      var _loop = function _loop(i) {\n        var startIndex = unloadedRanges[i];\n        var stopIndex = unloadedRanges[i + 1];\n        var promise = loadMoreItems(startIndex, stopIndex);\n        if (promise != null) {\n          promise.then(function () {\n            // Refresh the visible rows if any of them have just been loaded.\n            // Otherwise they will remain in their unloaded visual state.\n            if (isRangeVisible({\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\n              startIndex: startIndex,\n              stopIndex: stopIndex\n            })) {\n              // Handle an unmount while promises are still in flight.\n              if (_this2._listRef == null) {\n                return;\n              }\n\n              // Resize cached row sizes for VariableSizeList,\n              // otherwise just re-render the list.\n              if (typeof _this2._listRef.resetAfterIndex === 'function') {\n                _this2._listRef.resetAfterIndex(startIndex, true);\n              } else {\n                // HACK reset temporarily cached item styles to force PureComponent to re-render.\n                // This is pretty gross, but I'm okay with it for now.\n                // Don't judge me.\n                if (typeof _this2._listRef._getItemStyleCache === 'function') {\n                  _this2._listRef._getItemStyleCache(-1);\n                }\n                _this2._listRef.forceUpdate();\n              }\n            }\n          });\n        }\n      };\n\n      for (var i = 0; i < unloadedRanges.length; i += 2) {\n        _loop(i);\n      }\n    }\n  }]);\n  return InfiniteLoader;\n}(PureComponent);\n\nexport default InfiniteLoader;\n"]},"metadata":{},"sourceType":"module"}